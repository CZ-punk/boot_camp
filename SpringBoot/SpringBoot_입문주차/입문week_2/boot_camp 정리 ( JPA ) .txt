boot_camp 정리 ( JPA 및 영속성 컨텍스트 ) 





* JAVA PERSISTENCE APPLICATION *

- Object Relation Mapping 기술

- DB 와 백엔드 서버의 Entity 를 쉽게 매핑하여 데이터를 조작하게 도와준다.

- 구현체로 Hibernate 를 사용 ( 사실상 표준 구현체 )





* Entity *

- JPA 에서 관리되고 있는 클래스 ( 객체 ) ( db table 과 매핑되어 관리 )

- 자바 환경과 Spring 환경에서 JPA 를 다루는 부분이 다르다. ( 추후 체크 )


- JPA 는 Entity class 를 인스턴스화 할 때 Default Constructor 를 사용한다. 

- entity class 의 필드 ( column ) 에 제약 조건을 걸 수 있다.


@Column(name = "username", nullable = false, unique = true)

=> 열의 이름 username , null 불가 , 중복 불가

@Column(name = "contents", nullable = false, length = 500)

=> 열의 이름 contenst , null 불가 , 길이 500 이하 

@Id 

=> Pk 인 필드에 작성 필수 




* resources 의 META-INF 디렉토리의 Persistence.xml 파일 *

- entity 클래스로 관리할 class 의 경로

- datasource 에 대한 정보 ( Spring 에서 properties 파일보고 세팅하는 것과 동일한 메커니즘 ) 

	- xml 파일 보고 자동으로 주입 및 설정

자바라서 위의 경로 및 환경에 설정을 하는 것임 ( Spring 이 었다면 application.xml or . properties 설정 )


EntityManagerFactory 를 통해 인자로서 xml 파일에 정의한 PersistenceUnit 을 주면 

해당 Unit 과 연동된 EntityManagerFactory 를 생성하고 Factory 에서 EntityManager 를 꺼내서

해당 Unit 과 연동된 Entity class 와 CURD 및 db 와의 정보 통신이 가능해진다.

Transaction 에 여러 sql 을 담아 수행 후, 모든 수행을 성공하면 commit , 실패하면 rollback





* 영속성 컨텍스트 * 

- 1차캐시

	- key & value 인 Map 의 형태로서 1차캐시에 미리 저장한다. 

		- key : PK , value : 해당 pk 를 갖는 Entity


- 저장 시

	- 해당 entity 를 setting 후 em.persist( entity ) 를 넣으면 일단 1차 캐시 내부에서는

		- pk , entity 로 Map 의 형태로 저장을 먼저한다.

		- flush 또는 commit 을 통해 db 에 값이 저장되는 것이다.

		- debuging 으로 persistenceContext 확인하면 내부에 값을 확인할 수 있다. ( 실제 캐시 환경 )



- 만약 조회시 1차 캐시에 없을 경우

	- 조회시 1차 캐시에 찾는 Entity 가 존재하지 않을 경우 DB 에 select query 를 날려 db 로부터 조회

	- 조회시 1차 캐시에 존재하면 1차 캐시 내부에서 해당 entity 를 가져온다.





* 객체 동일성 * 

1차 캐시를 이용해 DB Row 1개당 객체 1개가 사용하는 것을 보장.

ex)

db 로부터 조회된 pk = 1 인 entity 를 가져와 객체 선언 ( 해당 과정에서 1차 캐시에 저장된다. )

이후, 1차 캐시로부터 또 pk = 1 인 entity 를 조회 후 객체 선언 ( 이때는 1차 캐시로부터 조회 )

2개의 객체의 Reference 값을 확인하면 동일하다. ( 동일한 pk 에 대해서 값을 가져왔기 때문 )




- db 의 데이터 삭제시

	- 삭제할 entity 가 1차 캐시에 존재한다면 

	- 삭제할 entity 가 1차 캐시에 존재하지 않다면 db 로부터 select query 후 delete query 

	- debugging 할 때, entityEntryContext -> nonEnhancedEntityXref -> @@ ( managed  상태 )

		- Managed : 영속성 컨텍스트에서 관리하고 있다는 뜻

	- code 의 remove line 을 만나면서 managed -> deleted 상태로 변한다 ( 아직까지는 db 에 존재 ) 

	- 이후, commit 을 만나게 되면서 db sql 나가면서 data 삭제


참고: 

데이터의 삽입, 삭제, 수정 ( 즉, 데이터의 변경 발생 )시에는 Credential 한 작업이므로 

항상 Transaction 내에서 동작해야하며 성공과 실패에 따라 commit 과 rollback 처리를 해줘야 한다.

		


* 쓰기 지연 *

- Transaction 을 건 상태에서 Transaction 내의 작업들을 " 쓰기 지연 저장소 " 에 저장했다가

Transaction 이 종료되면 성공 유무에 따라 Transaction 이 commit 된다면 db 에 sql 을 한번에 모아 보낸다.

Debuggin 모드로 실행하고 , EntityManager 의 actionQueue 가 쓰기 지연 저장소 역할을 수행한다.

- insertions 에 size 정보가 존재. 

쓰기 지연 저장소에 존재하는 모든 Entity 를 Transaction commit 후 sql 이 나가면서 db 에 저장된다.

commit 호출 후, em.flush 가 호출된다.




* flush *

- 영속성 컨텍스트의 정보를 db 에 반영하는 역할 수행 ( 쓰기 지연 저장소에 있는 정보를 db 에 요청 저장 )

insert update delete 와 같이 데이터의 변경이 필요한 작업을 transaction 내에서만 수행해야 한다.

( tx 환경에서 하지 않으면 TrasactionRequiredException 예외 발생 )

( select 처럼 조회할 때도 필요한 경우가 종종 있긴하다. 추후 학습 )




* JPA update 처리 *

Entity Manager 에서 em.flush 호출될 때!

1차 캐시의 loadedState (처음 db로부터 가져온 Entity) 와 1차 캐시의 entity ( 현재 Entity ) 를 비교한다.

	- 이때, 1차 캐시의 Entity 는 변경됐을 수도 안 됐을 수도 있다.

	- 만약, 변경사항이 존재하여, LoadedState 의 Entity 와 현재 Entity 의 상태가 다를 시

		- update query 를 db 에 요청한다.  ( 변경사항 없으면, 안한다. )
 
- dirty checking  ( this entity .... nonEnhencedEntityXref 내용 확인하면 dirty chceking 확인 가능 )
	
	- 최초 상태인 LoadedState 와 현재 상태인 EntityInstance 의 값을 확인할 수 있다.

	- dirty checking 도 tx 내에서만 동작 가능하다.




정리:	

영속성 컨텍스트

1. 1차 캐시 기능 ( map 자료 구조 , 효율적 관리 )

2. 쓰기 지연 ( Transaction 처럼 데이터 내용을 쓰기 지연 저장소에 담아서 commit 시점에 한번에 변경 )

3. 변경 감지 ( 최초상태 LoadedState 와 현재 상태 EntityInstance 를 확인해서 update query 생성 호출 )

		- 변경감지는 commit 시점 ( 더 자세하게는 flush 호출시 )



