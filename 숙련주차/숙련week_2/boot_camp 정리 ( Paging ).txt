boot_camp 정리 ( Paging )





* Paging 기능 *

sort 조건, sort 방식, page 당 노출 수, total page 수 등을 조작 가능





* 동작흐름 *


< Controller Code >

    @GetMapping("/products")
    public Page<ProductResponseDto> getProducts(
            @RequestParam("page") int page,
            @RequestParam("size") int size,
            @RequestParam("sortBy") String sortBy,
            @RequestParam("isAsc") boolean isAsc,
            @AuthenticationPrincipal UserDetailsImpl userDetails) {
        return productService.getProducts(userDetails.getUser(),
                page - 1, size, sortBy, isAsc);
    }

- Client 의 요청을 queryParam 형태로 Paging 에 대한 정보를 받아 가져온다.

- Controller 는 페이징 처리에 대한 로직을 Service 로 던진다. ( 위임 )

- 이때, Client 에서 준 page 정보를 -1 을 하여 보내는 이유

	- client 에서는 page 가 1부터 시작

	- server 에서 page 는 0부터 시작




< Service Code >

    public Page<ProductResponseDto> 
	getProducts(User user, int page, int size, String sortBy, boolean isAsc) {

        Sort.Direction direction = isAsc ? Sort.Direction.ASC : Sort.Direction.DESC;
        Sort sort = Sort.by(direction, sortBy);
        Pageable pageable = PageRequest.of(page, size, sort);

        UserRoleEnum role = user.getRole();

        Page<Product> productList;
        if (role  == UserRoleEnum.USER) {
            productList = productRepository.findAllByUser(user, pageable);
        } else {
            productList = productRepository.findAll(pageable);
        }

        return productList.map(ProductResponseDto::new);
    }

- Client 로 받아온 정보를 토대로 Sort.Direction 객체를 생성해 오름/내림차순을 설정한다.

- 생성한 direction 객체와 sortBy 에 대한 정보를 가지고 Sort 객체를 생성한다.

	- 이때, sortBy 는 "어떤 필드를 조건으로 정렬할 지" 에 대한 Client 에서 보낸 정보이다.

		- ex )  가격 , 등록일 , 상품명 등의 기준

- PageRequest.of 메서드를 통해 page , size , sort 정보를 인자로 주어 Pageble 객체를 생성한다. 

	- 이때, page 는 "조회할 페이지 번호"

	- size 는 "한 페이지에 보여줄 상품 개수"

	- sort 는 "정렬에 대한 조건들의 정보" ( 오름/내림차순 , 정렬 속성 기준 )
	
	- 참고 : PageRequest 객체의 부모는 Pageable ( 최상위임 )

( 페이징과 관계가 없지만, User 의 Role 에 의해 상품의 보여주는 범위를 정하는 로직 포함 )

- Page<Product> 객체를 생성해서 User 의 Role 에 따른 Page<Product>Type 을 반환하도록 구성

	- 이 떄, Page<ProductResponseDto> 로 변환할 때, 

		Page 객체가 제공하는 map 기능으로 쉽게 변환 가능

		( List 의 Product 를 뽑아 순차적으로 ProductResponseDto 로 변환하는 것과 동일 )






page 정보를 줄 때,

- client 에서는 1부터 시작, 근데 Pageable pageRequest 에서는 0부터 시작한다.

( client 에서 받아온 page 값  - 1 을 해준다.  서버 쪽에서는 0 부터 시작해야 하므로 )



** Page Query **


select

    p.title,
    pf.product_id

from product p

left join product_folder pf

on p.id = pf.product_id

where p.user_id = 10

and pf.folder_id = 7

order by p.id

limit 10, 1;

- Paging Query 에서는 Limit 을 통해 page 수를 제한한다

- limit 앞, 뒤 숫자를 지정하는데

	- 앞의 숫자는 시작할 페이지 번호이다. 

	- 뒤의 숫자는 시작 페이지 번호부터 나열할 페이지의 개수이다. 

	- ex) 총 15개의 entity 가 존재한다고 가정

		- limit 3, 10 >> 4번째 Index 를 시작으로 10개의 Entity 를 보여준다.

		- limit 11 >> 0번째 Index 를 시작으로 11개의 Entity 를 페이징 처리하여 보여준다.

	- DB 에서의 Paging 은 0번부터 시작한다.

	- cf) Web 즉, 클라이언트에서의 Paging 은 1부터 시작한다.



