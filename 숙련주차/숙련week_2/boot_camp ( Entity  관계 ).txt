boot_camp ( Entity  관계 )




* 1:N , N:1 , N:M , 1:1 *

- DB 테이블에서는 테이블 사이의 연관관계를 FK 로 맺을 수 있고, 방향 상관없이 조회 가능

- Entity 에서는 상대 Entity 를 참조하여 Entity 사이의 연관관계를 맺을 수 있다.

	- 하지만, 상대 Entity 를 참조하지 않고 있다면 상대 Entity 를 조회할 방법 없다.

	- 따라서, Entity 에서는 DB 테이블에 없는 방향의 개념이 존재한다.

	- ex) User , Food Table 사이 User 가 Food entity 에 대한 필드 없을 때, User 통한 Food 조회 불가

	- 즉, Entity 서로가 참조하는 형태: 양방향 , 한쪽만 참조하는 형태: 단방향






* 단방향 관계 *

- 일반적으로 외래키의 주인은 N(다) 의 관계인 Entity 가 주인이 되어 갖는다.

- 외래키의 주인만이 FK 등록, 수정, 삭제할 수 있으며, 주인이 아닌 쪽은 오직 FK 를 읽기만 가능

- @JoinColumn() 은 FK 의 주인이 활용하는 애노테이션

	- 컬럼명, NULL 여부, Unique 여부 등을 지정할 수 있음


결론:

- FK 주인만 상대 Entity type 을 필드로서 가지고 @JoinColumn 을 사용해 Key 의 속성을 지정하면 된다.






* 양방향 관계 *

- 각 Entity 가 서로의 Entity 필드를 가지고 있다.

- JPA 에서는 양방향일 때, 누가 FK 주인인지 알려줘야 한다. 

	- FK 주인이 "아닌" 쪽에 mappedBy 옵션 사용

	- mappedBy 속성값은 FK 주인인 상대 Entity 에 있는 필드명을 의미!

		- 즉, 외래키로서 지정되는 Entity 필드명

		- ex) food entity 의 필드인 private User user 의 user!

정리:

- 외래키 주인 부분은 단방향과 동일하게 설정하고,

- FK 주인이 아닌 Entity 에는 FK 주인 타입의 필드를 가지면서 해당 필드 부분에 mappedBy 옵션을 적용

적용할 속성값은 FK 주인이 갖는 내 Entity type 필드의 필드명을 작성, 

위와 같은 작업을 하면 JPA 에서는 양방향 관계의 주인을 인식할 수 있다.




참고:

위와 같은 1:1 관계가 아닌 1:N 관계에서 @JoinColumn 애노테이션을 생략하면 

FK 를 갖는 주인 테이블을 JPA 가 인지할 수 없게 되고 내부적으로 중간 테이블을 설계한다.

- 1:1 , 1:N 상관없이 @JoinColumn 애노테이션을 활용해 명시적으로 주인 테이블을 지정해 JPA 알리자.


또, 양방향 관계에서 mappedBy 옵션을 생략하면 JPA 가 주인 Entity 를 파악 불가

( 의도치 않은 중간 테이블 설계 문제 발생 )




추가:

- Trasaction 과 영속성 컨텍스트 생명주기 동일 ( Tx 환경에서 영속성 컨텍스트 기능 사용 가능 )

	- Tx 환경이 아닐 때, 영속성 컨텍스트 ( db 와 소통 ) 불가 ( 읽기정도는 가능 )

	- Tx 환경이 아닐 때, Dirty Checking 도 불가능 ( insert , update , delete 동일 )

- save 할 때, Tx 환경이어야만 하는 이유:

	- 만약, 여러개의 entity 를 save 할 때, 그 중 중간에서 오류가 발생하면..

		- 전부 rollback 해야 하지만,

		- tx 환경이 아닐 경우, 오류가 나기전 insert 를 수행했던 entity 들은 저장되어 db 꼬인다.

			- 물론 상황에 따라 다르다. 




* 1:N 관계 *

- Food Entity 와 User Entity 간의 관계에서 Food 가 FK 주인이지만, 1:N 관계 ( Food -> User 단방향 )

즉, FK 의 주인은 원래 Food 지만, FK 를 User 가 가지고 있을 경우이다.

	- 고객의 Entity 에는 Food entity 의 필드는 없지만, db column FK 로서 Food 가 존재한다.

	- Food Entity 에는 List <User> 가 존재한다. ( Food -> User 로 단방향 조회를 하기 때문 )

- 현재 상황에서는 user table 에 food 를 fk 로서 가져야 하므로 

	- 구조상 Food Entity 를 @OneToMany 로 @JoinColumn 의 name 을 food_id 로 user table 저장


즉, FK 의 주인은 Food 지만, db table 에는 User 에게 FK 만 맡기고 Entity 에서의 관리는 Food 가 한다!

+

1:N 관계에서 양방향 매핑은 JPA 에서 지원하지 않는다. ( 억지 표현은 가능 )

- 각각 @JoinColumn 으로 참조할 수는 있다.

- 대신 FK 의 주인이 아닌 쪽에서는 fk 에 대해 controll 불가능

	- joinColumn option 으로 insertable , updatable = false 로 주어 읽기전용 표현 가능


실행해보면  User 를 먼저 세팅하고 food 를 저장하고 다시 User 와 Food 관계를 매핑하면서 

User table 에 Food entity 에 대한 FK 를 세팅하는데 추가적인 Update Query 가 발생하면서 성능 저하

	-	-	-	-추천하지 않는 방법이다.	-	-	-






* N:M 관계 *

- N:M 관계는 중간 테이블을 생성해 풀어서 사용해야 한다.

다대다 관계에서 FK 주인이 Food 인 상황,

- @JoinTable 애노테이션을 사용해서 중간테이블을 편리하게 생성 가능하다.

	- 옵션으로는 name = "테이블 명", 

	- JoinColumns = @JoinColumn(name = "food_id") : 현재 위치인 Food Entity 의 pk column

	- inverseJoinColumns = @JoinColumn(name = "user_id") : 반대 위치인 User Entity 의 pk column


즉, 새로 생성할 중간 테이블을 food table column "food_id" 와 User table column 인 "user_id" 를

매핑해서 중간 테이블을 설계한다. ( 중간 테이블은 FK 만 2개 )

=> JPA 에서 만들어 준 중간테이블은 조작하기에 불편하다. 


불편한 이유:

	- PK 없음 , 우리가 직접 생성한게 아니라 추가 변경사항 발생시 관리 힘듦

	- 중간 테이블을 직접 만들어서 사용해보자!



* Orders 중간 테이블 생성 및 구현 *

- 일반적으로 FK 의 주인이 FK 를 가지고 있으며, Many(다) 인 부분이 FK 를 가지고 주인이 된다.

Food 와 User 의 관계에서 다대다 관계이므로 해당 관계를 중간 테이블 Orders 를 두어

Food 와 Orders 를 1:N 관계, ( 하나의 Food 는 여러번 주문될 수 있음 )

User 와 Orders 를 1:N 관계, ( 한명의 User 는 주문을 여러번 할 수 있음 )


만약, Food Table 에서 Order 를 거쳐 User 를 조회할 이유가 없다면

- user entity 부분에 양방향으로 매핑할 이유가 없음 ( 반대도 마찬가지 )

강의에서는 중간 테이블을 거쳐 서로의 Entity 를 조회할 수 있도록 코드 구성되어 있다. ( 양방향 매핑 )


중요!

- db 에 연관관계로 매핑된 데이터를 조작하기 위해서는 FK 가 존재하는 entity 의 정보를 수정해야 한다.

