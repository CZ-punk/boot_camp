boot_camp ( Entity  관계 )




* 1:N , N:1 , N:M , 1:1 *

- DB 테이블에서는 테이블 사이의 연관관계를 FK 로 맺을 수 있고, 방향 상관없이 조회 가능

- Entity 에서는 상대 Entity 를 참조하여 Entity 사이의 연관관계를 맺을 수 있다.

	- 하지만, 상대 Entity 를 참조하지 않고 있다면 상대 Entity 를 조회할 방법 없다.

	- 따라서, Entity 에서는 DB 테이블에 없는 방향의 개념이 존재한다.

	- ex) User , Food Table 사이 User 가 Food entity 에 대한 필드 없을 때, User 통한 Food 조회 불가

	- 즉, Entity 서로가 참조하는 형태: 양방향 , 한쪽만 참조하는 형태: 단방향






* 단방향 관계 *

- 일반적으로 외래키의 주인은 N(다) 의 관계인 Entity 가 주인이 되어 갖는다.

- 외래키의 주인만이 FK 등록, 수정, 삭제할 수 있으며, 주인이 아닌 쪽은 오직 FK 를 읽기만 가능

- @JoinColumn() 은 FK 의 주인이 활용하는 애노테이션

	- 컬럼명, NULL 여부, Unique 여부 등을 지정할 수 있음


결론:

- FK 주인만 상대 Entity type 을 필드로서 가지고 @JoinColumn 을 사용해 Key 의 속성을 지정하면 된다.






* 양방향 관계 *

- 각 Entity 가 서로의 Entity 필드를 가지고 있다.

- JPA 에서는 양방향일 때, 누가 FK 주인인지 알려줘야 한다. 

	- FK 주인이 "아닌" 쪽에 mappedBy 옵션 사용

	- mappedBy 속성값은 FK 주인인 상대 Entity 에 있는 필드명을 의미!

		- 즉, 외래키로서 지정되는 Entity 필드명

		- ex) food entity 의 필드인 private User user 의 user!

정리:

- 외래키 주인 부분은 단방향과 동일하게 설정하고,

- FK 주인이 아닌 Entity 에는 FK 주인 타입의 필드를 가지면서 해당 필드 부분에 mappedBy 옵션을 적용

적용할 속성값은 FK 주인이 갖는 내 Entity type 필드의 필드명을 작성, 

위와 같은 작업을 하면 JPA 에서는 양방향 관계의 주인을 인식할 수 있다.




참고:

위와 같은 1:1 관계가 아닌 1:N 관계에서 @JoinColumn 애노테이션을 생략하면 

FK 를 갖는 주인 테이블을 JPA 가 인지할 수 없게 되고 내부적으로 중간 테이블을 설계한다.

- 1:1 , 1:N 상관없이 @JoinColumn 애노테이션을 활용해 명시적으로 주인 테이블을 지정해 JPA 알리자.


또, 양방향 관계에서 mappedBy 옵션을 생략하면 JPA 가 주인 Entity 를 파악 불가

( 의도치 않은 중간 테이블 설계 문제 발생 )


추가:

- Trasaction 과 영속성 컨텍스트 생명주기 동일 ( Tx 환경에서 영속성 컨텍스트 기능 사용 가능 )

	- Tx 환경이 아닐 때, 영속성 컨텍스트 ( db 와 소통 ) 불가 ( 읽기정도는 가능 )

	- Tx 환경이 아닐 때, Dirty Checking 도 불가능 ( insert , update , delete 동일 )

- save 할 때, Tx 환경이어야만 하는 이유:

	- 만약, 여러개의 entity 를 save 할 때, 그 중 중간에서 오류가 발생하면..

		- 전부 rollback 해야 하지만,

		- tx 환경이 아닐 경우, 오류가 나기전 insert 를 수행했던 entity 들은 저장되어 db 꼬인다.

			- 물론 상황에 따라 다르다. 

