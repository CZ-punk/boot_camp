boot_camp 정리 ( Springboot JPA ) 





* Spring boot 의 자동화 *

- SpringBoot 는 EntityMangerFactory 와 EntityManager 를 자동으로 생성해준다.

	- JAVA 에서는 META-INF 의 persistence.xml 파일의 정보를 제공해서 사용했었다.

	- SpringBoot 에서는 application.properties 또는 yml 파일의 정보를 확인 후 자동 등록 및 생성


Spring 의 Transaction

- JPA 에게 db 의 Tx 개념을 부여해야 한다. ( 기존에는 em 를 통해 EntityTransaction 가져와서 사용했다. )

- tx 환경을 만드는 방법 ( SimpleJpaRepository lib 확인 )

- @Transactional 애노테이션을 class 나 method 레벨에 걸어주면 해당 범위 내에서 Tx 환경을 생성해준다. 

( 읽기전용시 readOnly 옵션을 걸어준다. 해당 옵션 사용시 데이터 변경 불가, 변경하려하면 예외 발생 )

	- 조회 시 tx 환경이 필요한 경우에 걸어주는데 추후 다루겠다.





* Tx Test *

Transaction test 시

- @PersistenceContext 애노테이션을 통해 EntityManger em 을 주입받는다.

	- 이때, Test code class level 에 @SpringbootTest Annotation 을 남겨야한다. ( 추후 강의 )




* 생명주기 *

- Tx 와 영속성 컨텍스트의 생명주기는 동일하다 

- 즉, Tx 환경이 유지되면 영속성 컨텍스트의 기능 사용 가능 ( dirty Checking , 쓰기지연, 1차캐시 )

- 영속성 컨텍스트을 유지하려면 Tx 환경이 필요하다. ( CRUD 는 Tx 꼭 필요 )




* Transaction 전파 *

- Spring 에서는 Service 부터 Repository 까지 Transaction 을 이어서 유지해준다. 

- 부모 , 자식 method 둘 다 @Transactional 애노테이션이 걸려 있는 상황

	- 부모가 자식을 호출한다. ( em.find 해서 select query 를 날린다. )

	- 자식 메서드가 entity 를 수정

	- 자식 메서드가 끝나도 Tx 가 종료되지 않음  ( 부모의 Tx 가 자식까지 전파된 것이다. )

	- 자식 메서드 종료 후, 부모 메서드의 남은 로직 수행 

	- 부모 메서드까지 완전히 종료 후, Tx 이 끝나고 commit 됨에 따라 update query 를 수행


- @Transactional 의 Propagation 옵션을 설정해서 전파의 범위를 설정할 수 있다. )

	- Required : default 값이다. 

	- : 부모 메서드에 Tx 가 존재한다면 자식 메서드의 Tx 는 부모 메서드의 Tx 에 합류한다.

		- 즉,  자식이 부모 메서드 Tx 를 같이 쓴다. 
	
		- 계층 간 Tx 를 전파해서 사용 가능하다.


- 만약 테스트에서 부모 method 에는 @Transactional 없고, 자식 method 에만 존재할 경우

	- 자식 method 종료시 Tx 환경이 종료 후 commit 되어 변경감지 발생하여 update query 요청

	- 남은 부모 method 로직 수행 후, 정상 종료. 

		- ( 중요한건 위 테스트와 달리, 자식 method 종료시 tx 가 끝나 commit 된 것 )








ddl-auto: <option> 

- create : 시작시점 전부 새로 생성 ( create-drop 추가로 종료시점 table drop )

- update : 변경 부분만 반영 ( 테이블있다면 생성, 없다면 그대로 )

- validate : 매핑이 정상인지만 확인 ( table 과 entity 간 )

- none : 아무것도 안함 


* 